- [Usage | TypeGraphQL Prisma](https://prisma.typegraphql.com/docs/basics/usage) 
- .
    ```
    enum UserKind {
  NORMAL
  ADMIN
}

model User {
  id    String  @default(cuid()) @id @unique
  email String  @unique
  age   Int?
  kind  UserKind
}
    ```
- .
    ```
    export enum UserKind {
  NORMAL = "NORMAL",
  ADMIN = "ADMIN",
}
TypeGraphQL.registerEnumType(UserKind, {
  name: "UserKind",
  description: undefined,
});
    ```
- Autogenerated Typescript models `  generated/type-graphql/models/User.ts  ` 
- .
    ```
    @TypeGraphQL.ObjectType({
  isAbstract: true,
  description: undefined,
})
export class User {
  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined,
  })
  id!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined,
  })
  email!: string;

  @TypeGraphQL.Field(_type => Int, {
    nullable: true,
    description: undefined,
  })
  age?: number | null;

  @TypeGraphQL.Field(_type => UserKind, {
    nullable: false,
    description: undefined,
  })
  kind!: UserKind;
}
    ```
- The fastest way to expose all Prisma CRUD actions is to import `resolvers` from the output folder and just use it in the `buildSchema` function known from TypeGraphQL:  
- .
    ```
    import { resolvers } from "@generated/type-graphql";

const schema = await buildSchema({
  resolvers,
  validate: false,
});
    ```
- if you need more control
- .
    ```
    import { crudResolvers, relationResolvers } from "@generated/type-graphql";
    ```
- with Apollo
- .
    ```
    import { PrismaClient } from "@prisma/client";
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";

const prisma = new PrismaClient();

const server = new ApolloServer<MyContext>({
  schema, // from previous step
});
const { url } = await startStandaloneServer(server, {
  context: () => ({ prisma }),
  listen: { port: 4000 },
});
    ```
